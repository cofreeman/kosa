# 멀티스레드 프로그래밍

## 멀티프로세스와 멀티 스레드
- 프로세스: 실행 중인 프로그램
- 멀티 태스킹: 두 가지 이상의 작업을 동시에 처리하는 것
- 스레드: 프로세스 내에서 코드의 실행 흐름
- 멀티 스레드: 두 개의 코드 실행 흐름. 두가지 이상의 작업을 처리
- 멀티 프로세스: 실행 중인 프로그램이 2개 이상


쓰레드보다 프로세스를 생성하는 비용이 더 크기 때문에, 일반적으로 멀티스레딩을 구현하는 것이 프로세스를 생성하는 것보다 효율적입니다.

프로세스는 운영체제에서 실행되는 독립적인 실행 단위이며, 각각의 프로세스는 자신만의 주소 공간과 자원을 할당받습니다. 반면에 쓰레드는 하나의 프로세스 내에서 실행되는 실행 단위이며, 각각의 쓰레드는 같은 주소 공간과 자원을 공유합니다.

따라서 프로세스를 생성하는 비용은 매우 큽니다. 프로세스를 생성하기 위해서는 운영체제가 새로운 주소 공간과 자원을 할당해야 하기 때문입니다. 반면에 쓰레드를 생성하는 비용은 비교적 작습니다. 쓰레드는 이미 생성된 프로세스의 주소 공간과 자원을 공유하기 때문에, 운영체제는 별도의 자원을 할당할 필요가 없습니다.

**정리: 따라서 멀티스레딩을 구현하는 것이 프로세스를 생성하는 것보다 효율적입니다. 멀티스레딩은 프로그램의 성능을 향상시키고, 자원을 효율적으로 활용할 수 있도록 도와줍니다.**

구현하고자 하는 프로그램이 여러개의 흐름이 병렬적으로 처리되어야한다 -> 멀티 쓰레드 프로그램을 만들어야겠다 -> 각 쓰레드들의 기능이 무엇인지 생각 -> 기능별로 쓰레드를 구현 


### 사용법
쓰레드를 생성하는 데 Java에서는 두 가지 주요 방법이 있습니다: Thread 클래스를 확장하는 것과 Runnable 인터페이스를 구현하는 것입니다.
두 방법에는 몇 가지 차이점이 있습니다.

1. Thread 클래스 확장:

- Thread 클래스를 상속받아 자식 클래스를 생성합니다.
- run() 메서드를 재정의하여 쓰레드가 실행할 작업을 정의합니다.
- 클래스를 상속받았기 때문에 다른 클래스를 상속받을 수 없습니다 (Java는 다중 상속을 지원하지 않음).

2. Runnable 인터페이스 구현:

- Runnable 인터페이스를 구현하는 클래스를 생성합니다.
- 인터페이스를 구현하므로, 클래스는 다른 클래스를 상속받을 수 있습니다.
- run() 메서드를 구현하여 쓰레드가 실행할 작업을 정의합니다.
- 쓰레드를 시작하려면 Runnable 객체를 Thread 객체의 생성자에 전달하고, Thread의 start() 메서드를 호출해야 합니다.

Thread 클래스를 확장하면 다른 클래스를 상속받을 수 없으므로, Runnable 인터페이스를 구현하는 것이 더 유연합니다.
Runnable 인터페이스를 구현하는 것은 코드 재사용과 객체 지향 디자인 원칙에 더 부합합니다.

둘 다 run method 가 접근 제어자가 public 이므로 public 을 상속받아야한다

thread 의 start() 메서드를 호출하면 새로운 스택이 생성된다.

thread.join() 메서드를 쓰면 자식 쓰레드가 끝날 때까지 대기하게 된다.


### 스레드 상태
- 실행 대기 상태: 실행을 기다리고 있는 상태
- 실행 상태: CPU 스케쥴링에 따라 CPU를 점유하고 run() 메소드를 실행.
- 스케줄링에 의해 다시 실행 대기 상태로 돌아갔다가 다른 스레드가 실행 상태 반복 종료 상태: 실행 상태에서 run() 메소드가 종료되어 실행할 코드 없이 스레드의 실행을 멈춘 상태

### Daemon Thread
> 주 스레드의 작업을 돕는 보조적인 역할을 수행하는 스레드

- 주 스레드가 종료되면 데몬 스레드도 따라서 자동 종료
- 데몬 스레드를 적용 예: 워드프로세서의 자동 저장, 미디어플레이어의 동영상 및 음악 재생,
  가비지 컬렉터

????????????????????????????????????
스프링 프레임워크에서 쓰레드가 많이 쓰여? 
톰캣에서 쓰레드가 많이 쓰여?
????????????????????????????????????

## Synchronized 키워드
> 공유 자원에 대한 여러 쓰레드의 접근을 제한할 때 쓰는 키워드

## 동기화 된 컬렉션
멀티 쓰레드 환경에서 하나의 콜렉션 객체에 접근할 때 안전하게 처리할 수 있다.

사용예시
```java
public static void main(String[] args) {
		ArrayList<Object> objects = new ArrayList<>();
		List<Object> objects1 = Collections.synchronizedList(objects);
		
	}
```
write 작업량이 적으면 CopyOnWrite 메서드로 동기화를 하면 된다.


# 람다

### 함수형 프로그래밍
> 함수를 정의하고 이 함수를 데이터 처리부로 보네 데이터를 처리하는 기법

### 람다식
> 메서드 정의를 하나의 식으로 표현한것
-> 자바에서 함수적 프로그래밍 지원 기법으로서 익명 클래스 객체가 된다.
> 
