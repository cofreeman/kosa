# 람다식 메서드 참조

### 정적 메서드와 인스턴스 메서드 참조
- 람다식에서 정적 메소드를 참조할 경우 클래스 이름 뒤에 :: 기호를 붙이고 정적 메소드 이름을 기술
- 인스턴스 메소드일 경우에는 객체를 생성한 다음 참조 변수 뒤에 :: 기호를 붙이고 인스턴스 메소드 이름을 기술

추상메서드가 단 하나인 인터페이스를 정의한 후 메서드를 구현한다.
이 때 메서드가 하나 뿐이니 그것을 구현한 코드만 작성해주면 된다.
이제 (구현한 인터페이스.메서드이름(변수)) 를 쓰면 함수형 프로그래밍 완성
---

### Functional Interface with 가변인자, 제네릭
**다음과 같은 경우에는 람다식이 어떻게 쓰일까?**
```java
interface ActionExpression {
	void exec(Object... param);
}

interface FuncExpression<T> {
	T exec(Object... param);
}
```
---

# 스트림
- 스트림은 두종류다.
1. 자바의 I/O 스트림
2. 컬렉션, 배열 등에 저장된 요소들을 하나씩 참조하면서 코드를 실행할 수 있는 기능

- 스트림의 특징
1. Array, Collection에 동일한 연산이 수행돼서 일관성 있는 처리 기능을 갖게 한다
2. 스트림은 1회성이라 한번 사용한 스트림은 재사용 하지 못한다
3. 스트림의 연산은 기존의 자료를 변경하지 않고, 새로운 메모리 위에서 동작한다
4. 중간연산과 최종 연산이 구분되며, 최종 연산이 수행된 이후 모든 연산이 적용되는 지연연산을
  지원한다.
---
### 외부반복이란? 내부반복이란?
> 외부반복 : 일반적으로 사용하는 루프처럼 요소를 사용하는 쪽에서 직접 컬렉션 요소를 하나씩 꺼내 와서 반복 처리 

> 내부반복 : 처리할 행동(보통 콜백 함수)을 컬렉션 요소에 넘겨주어 반복 처리
---
### 내부반복(스트림)의 장점
- 내부 반복자이므로 처리 속도가 빠르고 병렬 처리에 효율적
- 람다식으로 다양한 요소 처리를 정의
- 중간 처리와 최종 처리를 수행하도록 파이프 라인 형성
- 내부 반복자의 이점은 어떻게 요소를 반복시킬 것인가는 컬렉션에 맡겨두고,
  개발자는 요소 처리 코드에만 집중
- 요소들의 반복 순서를 변경하거나, 멀티 코어 CPU를 최대한 활용하기 위해 요소들을 분배시켜
  병렬 작업을 할 수 있게 도와줌
---
### 스트림 얻는법
| ~ to stream    | 얻는법                                                                                                                                 |
|----------------|-------------------------------------------------------------------------------------------------------------------------------------|
| 컬렉션(List, Set) | Collection 인터페이스는 stream() 과 parallelStream() 메서드를 써서 자식 인터페이스인 List 와 Set 인터페이스를 구현한 모근 컬렉션에서 객체 스트림을 얻을 수 있다.                     |
| Map 컬렉션        | Map 은 collection 인터페이스를 상속받지 않으므로 entrySet(), values(), keySet() 을 사용하여 Collection 인터페이스를 상속받게 만든 다음 stream() 메서드를 사용할 수 있게 만들면 된다. |
| 배열             | Arrays 유틸클래스로부터 Arrays.stream(배열) 을 통해 스트림을 얻을 수 있다.                                                                                |
| 숫자 범위          | IntStream, LongStream 의 정적 메서드인 range(), rangeClosed() 메서드로 부터 특정범위의 숫자 스트림을 얻을 수 있음                                                |
| 파일             | Files 클래스의 lines() 메서드로 텍스트 파일의 행 단위 스트림을 얻을 수 있다.                                                                                  |
| 커스텀 스트림        | Stream.generate(Supplier), Stream.of(데이터) 로 커스텀 스트림을 만들 수 있음  ex) 로또 번호 생성기                                                         |
---
### 스트림 디버깅
스트림은 내부 반복이라 콜렉션 내부에서 모든 처리가 되는데 그러면 디버깅은 어떻게 하나요?
방법 1. peek(consumer) 메서드를 사용하여 내부 요소들을 처리할 수 있다. sout 등
방법 2.intellij 의 stream trace 기능을 사용하여 스트림 디버깅을 할 수 있다. 
---
### 내부 반복(stream) 이 외부 반복(for 등) 보다 좋다?

| -    | 이유                                                                                                                                                                                                                                                                  | 논란                                                                                                                                                                                            | 결론                                           |
|------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------|
| 이유 1 | stream 은 병렬연산을 지원하여 멀티 코어 cpu 를 사용할 수 있다. 작업을 분할해서 진행하므로 연산을 빠르게 할 수 있다.                                                                                                                                                                                            | 외부 반복도 Thread 를 이용해서 구현할 수 있다. 외부 반복을 thread 를 이용해서 구현하면 멀티코어를 사용하므로 속도에 이점이 있다고 볼 수 없다. 하지만 코드가 어렵고 더러워진다.                                                                                   | 내부 반복을 쓰면 외부 반복보다 병렬 처리를 더 쉽고 깔끔하게 구현할 수 있다. |
| 이유 2 | 중간 연산과 최종 연산을 분리함으로써 데이터 처리의 _유연성_ 과 _성능_ 을 향상시키는데 큰 도움이 된다.                                                                                                                                                                                                        | x                                                                                                                                                                                             | 부품 갈아끼우듯이 중간연산과 최종연산을 조립하여 원하는 계산을 할 수 있다.   |
| 이유 3 | 간결하고 가독성이 높음                                                                                                                                                                                                                                                        | x                                                                                                                                                                                             | 간결하고 가독성이 높음                                 |
| 이유 4 | 스트림은 Lazy 처리 방식을 지원하기 때문에 데이터를 필터링하거나 변환하는 작업만 시행하고 최종 연산을 수행하기 전까지는 실제 데이터 처리가 일어나지 않는다.                                                                                                                                                                           | for 문도 if 문 같은거로 불필요한 요소를 처리하지 않을 수 있다.  하지만 중간연산 최종연산이 나누어져 있지 않으므로 불필요한 연산을 할 수도있다.(예시 : stream 은 중간연산으로 싹다 걸러서 계산하는데 for 문 같은 경우는 계산 도중 불필요한 요소를 걸러내는 코드가 있으면 그 전까지는 불필요한 계산을 한 코드가 된다.  ) | 불필요한 요소에는 계산이 일어나지 않으므로 성능향상                 |
| 이유 5 | 함수형 프로그래밍 지원으로 불변성과 부작용을 제어해서 코드의 안전성과 유지보수성을 높힐 수 있습니다. 예를 들어 [코드 1] 같은 경우 기존 객체를 조작하므로 객체가 가변적이고 유지보수하기 어려운 코드입니다. 하지만 [코드2] 같은 경 원본 리스트는 변경되지 않으므로 불변성이 유지됩니다. 불변성이 유지되면 다른 코드에서 해당 객체를 참조할 떄 부작용이 일어나지 않으므로 안정성이 높아집니다.| x                                                                                                                                                                                             | 람다 캡처링으로 원본객체의 불변성을 유지하므로 안정성이 높아짐           |
[코드1]
```java
List<String> names = new ArrayList<>();
names.add("Alice");
names.add("Bob");
names.add("Charlie");

for (int i = 0; i < names.size(); i++) {
    if (names.get(i).equals("Bob")) {
        names.remove(i);
    }
}
```

[코드2]
```java
List<String> names = new ArrayList<>();
names.add("Alice");
names.add("Bob");
names.add("Charlie");

List<String> filteredNames = names.stream()
                                  .filter(name -> !name.equals("Bob"))
                                  .collect(Collectors.toList());

```
---
### 람다 캡처링
> 람다 함수나 람다 표현식에서 외부의 지역 변수나 매개 변수를 참조하는 것

람다식을 사용할 때 시그니처에 넘겨진 변수가 아닌 외부에서 정의 된 변수를 *자유 변수*라고 한다.

또한 람다바디에서 자유 변수를 참조하는 일을 **람다 캡처링** 이라고 한다.

람다 캡처링에는 두가지 제약사항이 있다.

제약 1. 지역변수는 final 이 있어야한다.

제약 2. final 이 붙어있지 않은 변수는 final 처럼 써야한다.(값의 재할당이 일어나면 안된다.)

제약사항이 있는 이유는 다음과 같다.
```java
int x = 0;

Runnable r = () -> {
    x = 1;
};

r.run();

System.out.println(x);
```
의 람다식에서 x 값을 탐조하고 변경합니다. 하지만 컴파일 에러가 발생하는데 람다식에서 캡처링한 변수의 값을 변경하는 것은 람다식이 실행되는 시점의 x 와 캡처링이 실행되는 시점의 x 의 값이 달라질 수 있기 때문입니다.

-> 무슨 말이죠? 람다식이 사용될때 람다식 내부에서 참조한 변수의 값이 외부 코드로 인해 변경된다면 결과값이 달라지므로 안정성을 보장할 수 없다는 말입니다. 

지역변수는 쓰레드간에 공유하지 않는다. 따라서 람다 캡처링을 할 때 값을 복사해서 각각의 쓰레드마다 사용된다. 

---

### stream 의 병렬 계산으로 인해 결과값이 달라지는 경우
스트림도 race condition 이 있다. 

따라서 작업의 순서에 의존적인 결과가 나오는 않는 경우에만 parallelStream 을 사용해야한다.

---
### 배열을 스트림으로 변환하는 과정은 어떻게 될까
배열 -> 리스트 -> 스트림인가?

정답 : 아니다. 그냥 배열을 바로 스트림으로 만든다.

---
### 외부 반복이 더 효율적인 경우
없는 것 같다.
싱글 코어 cpu 로 병렬 스트림처리를 하지 않는 이상 
---