# JPA
> JPA는 Java Persistence API 의 약자로서, RDBMS와 OOP 객체 사이의 불일치에서 오는 패러다임
을 해결하기 위해서 만들어진 ORM(Object-Relational Mapping) 기술이다.

## 특징
JPA 를 들어가기 전에 ORM 을 먼저 설명해야합니다.
ORM 은 Object-Relation-Mapper 로 rdbms 와 객체의 패러다임의 불일치를 해결하기 위한 기술입니다.
RDBMS(관계형 데이터베이스 관리 시스템)는 테이블 형태의 구조를 갖고 있으며, SQL을 사용하여 데이터를 조작합니다.
반면에 객체 지향 프로그래밍은 클래스와 객체로 구성되어 있으며, 상속, 다형성, 관계 등의 개념을 갖고 있습니다.

패러다임 불일치는 객체와 관계형 데이터베이스 간의 구조, 타입, 상속, 연관 관계 등의 차이로 인해 발생합니다.
ORM은 이러한 패러다임 불일치를 해결하기 위해 객체와 관계형 데이터베이스 간의 매핑 작업을 자동화하고, 데이터베이스와의 상호작용을 객체 지향적인 방식으로 처리할 수 있도록 도와줍니다.

ORM은 객체와 테이블 간의 매핑 정보를 정의하고, 데이터베이스와의 상호작용을 위해 필요한 SQL 쿼리를 자동으로 생성 및 실행합니다.
개발자는 SQL 쿼리를 직접 작성하지 않고도 객체 지향적인 코드로 데이터베이스와의 상호작용을 처리할 수 있습니다.
ORM은 객체 그래프를 통해 객체 간의 관계를 다루며, 필요한 경우 지연 로딩, 캐싱, 트랜잭션 등의 기능을 제공하여 효율적인 데이터 액세스를 지원합니다.

JPA 는 ORM 기술의 표준이며 ORM을 구현하기 위한 인터페이스와 애노테이션으로 구성되어 있습니다. 
개발자는 JPA를 사용하여 객체와 테이블 간의 매핑 정보를 정의하고, JPA 프로바이더(구현체)가 이를 바탕으로 실제 ORM 기능을 수행하게 됩니다.
JPA 프로바이더는 JPA의 스펙을 구현한 구현체로, Hibernate, EclipseLink, OpenJPA 등이 JPA 프로바이더의 예시입니다.

Hibernate 는 JPA 라는 인터페이스의 구현체이며 JPA의 스펙을 구현한 ORM 프레임워크 중 하나입니다.

정리하자면 객체와 rdbms 의 패러다임 불일치를 해결하기 위한 기술인 ORM 의 스펙을 정의해놓은것이 JPA 이고 그 스펙을 구현한것이 Hibernate입니다.

## 왜 Hibernate를 선택하는가?
1. 성숙한 생태계: Hibernate는 많은 사용자와 커뮤니티를 보유한 성숙한 ORM 프레임워크입니다. 많은 문서, 예제, 지원 리소스 등이 제공되어 있어 개발자가 문제를 해결하고 지원을 받을 수 있습니다.
2. 널리 사용되는 ORM 프레임워크: Hibernate는 JPA의 구현체 중 하나로서 JPA의 스펙을 준수하면서도 개별적인 기능과 확장성을 제공합니다. 많은 개발자들이 Hibernate를 선택하여 사용하고 있어 기술적인 문제를 해결하는 데 도움이 됩니다.
3. 다양한 기능과 성능 최적화: Hibernate는 다양한 기능을 제공하여 개발자가 편리하게 데이터베이스와 상호작용할 수 있습니다. 지연 로딩, 캐싱, 배치 처리 등의 성능 최적화 기능을 포함하여 데이터 액세스를 효율적으로 처리할 수 있습니다.
4. 유연성과 확장성: Hibernate는 JPA 스펙을 준수하면서도 개별적인 확장 기능을 제공합니다. 사용자 정의 타입 매핑, 이벤트 리스너, 상속 전략 등을 통해 데이터베이스와의 상호작용을 유연하게 처리할 수 있습니다.
5. 문제 해결 및 버그 수정: Hibernate는 오랜 기간 동안 개발되어왔고, 많은 버전 업데이트와 유지보수가 이루어져 왔습니다. 따라서 버그 수정과 문제 해결에 대한 노력과 경험이 쌓여 있어서 안정성을 보장할 수 있습니다.
6. 벤더 독립성: Hibernate는 다양한 데이터베이스 벤더와 호환되며, 데이터베이스에 종속적인 코드를 최소화하여 애플리케이션의 이식성과 유연성을 높일 수 있습니다.

## JPA 프로그래밍

1. EntityManagerFactory를 만든다.
2. EntityManager 를 만든다.
3. EntityManager 를 이용해 DB 와 상호작용을 수행한다.

### EntityManagerFactory
> JPA에서 데이터베이스와의 연결을 설정하고 EntityManager를 생성하는 역할을 담당하는 인터페이스입니다.

### EntityManager
> 말 그대로 엔티티를 매니징할 수 있는 객체이다.

EntityManager를 통해 엔티티의 저장, 조회, 수정, 삭제 등의 작업을 수행할 수 있습니다.

EntityManagerFactory와 EntityManager는 JPA에서 데이터베이스와의 상호작용을 위한 중요한 객체들이며, 엔티티의 영속성 관리, 트랜잭션 처리 등을 위해 사용됩니다.

### EntityManager 의 메서드
|메서드|설명|
|---|---|
|flush()|영속성 컨텍스트(Persistence Context)의 변경 내용을 데이터베이스에 반영한다.일반적으로는 flush() 메서드를 직접 사용하지는 않고, 자바 애플리케이션에서 커밋 명령이 들어왔을 때 자동으로 실행된다.|
|detach()|특정 Entity를 준영속 상태(영속 컨텍스트의 관리를 받지않음)로 바꾼다.|
|clear()|Persistence Context를 초기화한다.|
|close()|Persistence Context를 종료한다.|
|merge()|준영속 상태의 엔티티를 이용해서 새로운 영속 상태의 엔티티를 반환한다.|
|find()|식별자 값을 통해 Entity를 찾는다.(DB 테이블의 데이터 또는 행을 찾는다.)|
|persist()|생성된 Entity 객체를 영속성 컨텍스트(Persistence Context)에 저장한다.|
|remove()|식별자 값을 통해 영속성 컨텍스트(Persistence Context)에서 Entity 객체를 삭제한다.|

# 영속성 컨텍스트
> db 와 상호작용하기 위한 Entity 를 관리하는 곳

## 특징
1. EntityManager 객체를 통해서만 접근이 가능하다.
2. JPQL 쿼리 실행 시 플러시 자동 호출

## 장점
1. SQL 쓰기 지연 저장소 제공(플러시 전 스냅샷과 다른 엔티티를 찾아서 쿼리문 생성후 db 에 반영)
2. 1차 캐시 제공(db 에 대한 접근을 최적화 시켜서 성능상의 이점을 줌)
3. 동일성 동등성 보장(1차 캐시에는 키 = 엔티티이름 + pk, 밸류 = 인스턴스 형태로 데이터를 저장하는데 같은 키를 조회하면 같은 주소값을 반환하여 동일성을 보장한다.)
4. 지연 로딩 지원(페치타입이 lazy 인 경우 엔티티를 조회하면 연관엔티티를 프록시형태로 가져오고 pk 값을 저장한다. 따라서 실제로 연관엔티티를 사용하기 전에는 연관 엔티티에 대한 쿼리문이 발생하지 않는다.)

## 영속성 컨텍스트와 CRUD 

### Create
객체를 생성하여 save 메서드를 호출하면 1차 캐시에 pk값을 0 또는 null 을 저장한 후 sql 쓰기지연 저장소에 insert 쿼리를 저장한다. 실제로는 DB 와 상호작용을 하지 않는다.
이후 entitymanager 를 이용하여 flush 를 호출하거나 트랜잭션이 끝나서 커밋을 요청하기전에 자동 flush 를 이용하거나 JPQL 사용을 해서 자동 flush 를 하면 DB 에 반영된다.

### Read
엔티티를 조회할 떄 1차 캐시를 조회한 후 엔티티가 있으면 가져오고 없으면 db를 조회해서 엔티티를 가져온다.

### Update
JPA 는 엔티티를 영속성 컨텍스트에 저장하는데 이를 스냅샷이라하고 flush 를 하기 전 스냅샷과 달라진 엔티티가 있나 더티체킹을 한다.
이 떄 변경된 엔티티 정보에 따라 SQL 문을 만들고 DB 와 동기화한다.

### DELETE
엔티티를 삭제하면 DB 에서 삭제가 된다.


?????
JPA교안
????