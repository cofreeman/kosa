#변수와 메서드
|변수의 종류 | 선언위치 | 생성시기           | 소멸시기           |
|---|---|----------------|----------------|
|iv = 객체 변수|클래스 영역| 클래스가 메모리에 올라갈때 | GC 가 소멸하길 원할 때 |
|cv = 클래스 변수(스태틱 변수, 공유변수)|클래스 영역 | 인스턴스 생성시       | GC 가 소멸하길 원할 때 |
|lv = 지역 변수|메서드 영역 | 변수 선언문 수행시     | GC 가 소멸하길 원할 때 |

JVM 의 GC 가 작동 할 떄 변수가 소멸 된다.
아무때나 stop the world 하면 전체 애플리케이션의 스레드를 일시 중지하고 GC 작업을 수행하므로,
전체적인 처리 속도가 감소한다.

또한 stop the world 가 발생하는 동 일반적으로 메모리와 CPU 리소스를 많이 사용되기 때문에 
변수의 소멸 시기는 변수를 참조가 끊길 때가 아니라 GC 가 실행될때가 되어야만 한다.

가능한 stop the world 를 사용할떄는 어플리케이션 전체의 성능에 큰 영향이 끼치지 않도록 주의해야한다.
그러면 stop the world 를 덜 일어나게 하려면 메모리 용량을 크게 하면 되나?
아니다. 메모리 용량을 무작정 늘리는 것은 항상 좋은 방법은 아니다.

메모리 용량을 늘리면 GC 의 stop the world 가 발생하는 빈도가 줄어들 수는 있으나
메모리 용량을 늘리면 메모리 사용량이 증가하고, 이에 따라 어플리케이션의 처리 속도도 느려질 수 있다.
(메모리 할당과 해제에대한 오버헤드, 메모리 관리 알고리즘의 비효율성, 메모리 지역성이 낮아지는 경우)

따라서 stop the world 를 최소화 하려면 적절한 메모리 용량을 선택하고, GC 튜닝을 통 GC 실행 횟수를 최소화 해야 한다.

이를 위해서는 어플리케이션 메모리 사용량과 GC 실행 횟수를 모니터링하고, 적절한 대처를 하면 된다.

#카드 클래스가 실행될 때 JVM 에서 일어나는 일
OOP1보충.pdf 참조
1. 클래스를 인터프리터가 실행시키면 jvm 위에서 CardTest 클래스가 Method Area 위에 로딩된다.
2. main 메서드가 실행되므로 Call Stack 에 main 메서드가 올라간다.
3. main 메서드가 실행되고 Card 클래스가 참조 될 때 (Card class, cv)이 Method Area 에 로딩된다.
4. skip
#상속과 생성자
A 클래스가 B 클래스를 상속받을 때 A 클래스를 생성하려면 B 클래스를 먼저 생성해야한다.
super() 로 해결한다.
###
B 클래스를 상속받은 A 클래스를 생성하면 Heap 메모리에는 A 객체와 B객체 두개가 생기고 
Heap 메모리의 A 객체에는 B 객체를 가르키는 포인터가 있다.








